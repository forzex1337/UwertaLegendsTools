<?xml version="1.0" encoding="utf-8"?>
<!--
///////////////////////////////////////////////////////////////////////////////////
// 
//  Copyright (c) 2014 Nailson <nailsonnego@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
// 
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////////
-->

<s:Window xmlns:fx="http://ns.adobe.com/mxml/2009" 
          xmlns:s="library://ns.adobe.com/flex/spark" 
          xmlns:mx="library://ns.adobe.com/flex/mx"
          xmlns:nail="library://ns.nail.com/naillib"
          xmlns:components="nail.otlib.components.*"
          xmlns:animationeditor="nail.animationeditor.*"
          width="800"
          height="600"
          minWidth="600"
          minHeight="500"
          fontSize="11"
          backgroundColor="0x494949"
          showStatusBar="false"
          title="@Resource(key='animationEditor', bundle='strings')"
          creationComplete="creationCompleteHandler(event)">
    
    <fx:Declarations>
        <fx:XMLList id="menuXML">
            <menuitem label="{resourceManager.getString('strings', 'menu.file')}">
                <menuitem label="{resourceManager.getString('strings', 'menu.open')}" data="fileOpen" keyEquivalent='O' icon="nail.assets.Icons_OPEN"/>
                <menuitem label="{resourceManager.getString('strings', 'export')}" data="fileExport" keyEquivalent='E' icon="nail.assets.Icons_EXPORT"/>
            </menuitem>
            <menuitem label="{resourceManager.getString('strings', 'menu.edit')}">
                <menuitem label="{resourceManager.getString('strings', 'paste')}" data="editPaste" keyEquivalent='V' icon="nail.assets.Icons_PASTE"/>
            </menuitem>
        </fx:XMLList>
    </fx:Declarations>
    
    <s:layout>
        <s:VerticalLayout/>
    </s:layout>
    
    <fx:Metadata>
        [ResourceBundle("strings")]
    </fx:Metadata>
    
    <fx:Script>
        <![CDATA[
            
            import com.worlize.gif.GIFDecoder;
            import com.worlize.gif.GIFFrame;
            import com.worlize.gif.events.GIFDecoderEvent;
            
            import mx.events.DragEvent;
            import mx.events.FlexEvent;
            import mx.events.MenuEvent;
            import mx.events.MoveEvent;
            import mx.managers.DragManager;
            
            import spark.events.IndexChangeEvent;
            
            import nail.animationeditor.events.FrameListEvent;
            import nail.assets.Icons;
            import nail.assets.NailAssets;
            import nail.codecs.ImageCodec;
            import nail.codecs.ImageFormat;
            import nail.components.controls.Alert;
            import nail.image.ClipboardBitmapLoader;
            import nail.managers.PopUpWindowManager;
            import nail.objectbuilder.core.IObjectBuilder;
            import nail.objectbuilder.utils.ObUtils;
            import nail.otlib.components.ExportWindow;
            import nail.otlib.components.SurfaceCells;
            import nail.otlib.geom.Size;
            import nail.otlib.sprites.SpriteData;
            import nail.otlib.things.ThingCategory;
            import nail.otlib.things.ThingData;
            import nail.otlib.things.ThingType;
            import nail.otlib.utils.OTFormat;
            import nail.otlib.utils.SpriteUtils;
			import nail.otlib.utils.ThingUtils;
            import nail.utils.FileUtil;
            import nail.utils.SaveHelper;
            import nail.utils.StringUtil;
            
            //--------------------------------------------------------------------------
            // PROPERTIES
            //--------------------------------------------------------------------------
            
            public var application:IObjectBuilder;
            
            private var _surfaceCells:SurfaceCells;
            private var _rect:Rectangle = new Rectangle();
            private var _size:Size = new Size(32, 32);
            private var _file:File;
            private var _fileChanged:Boolean;
            private var _bitmap:BitmapData;
            private var _nextBitmap:BitmapData;
            private var _bitmapChanged:Boolean;
            private var _mouseDown:Boolean;
            private var _zoom:Number;
            private var _zoomChanged:Boolean;
            private var _lastValues:Rectangle = new Rectangle();
            private var _transparency:Boolean = true;
            
            //--------------------------------------
            // Getters / Setters 
            //--------------------------------------
            
            public function get file():File { return _file; }
            public function set file(value:File):void
            {
                _file = value;
                _fileChanged = true;
                invalidateProperties();
            }
            
            public function get bitmap():BitmapData { return _nextBitmap ? _nextBitmap : _bitmap; }
            public function set bitmap(value:BitmapData):void
            {
                if (_bitmap != value) {
                    _nextBitmap = value;
                    _bitmapChanged = true;
                    invalidateProperties();
                }
            }
            
            public function get hasImage():Boolean { return (_bitmap || (imageControl && imageControl.source)); }
            
            [Bindable]
            public function get zoom():Number { return _zoom; }
            public function set zoom(value:Number):void
            {
                if (_zoom != value && value >= zoomSlider.minimum && value <= zoomSlider.maximum) {
                    _zoom = value;
                    _zoomChanged = true;
                    invalidateProperties();
                }
            }
            
            public function get transparency():Boolean { return _transparency; }
            public function set transparency(value:Boolean):void { _transparency = value; }
            
            //--------------------------------------------------------------------------
            // METHODS
            //--------------------------------------------------------------------------
            
            //--------------------------------------
            // Protected
            //--------------------------------------
            
            protected function update():void
            {
                if (!this.hasImage) return;
                
                _surfaceCells.cellWidth = _size.width;
                _surfaceCells.cellHeight = _size.height;
                _surfaceCells.columns = columnsStepper.value;
                _surfaceCells.rows = rowsStepper.value;
                
                var sw:uint = (_size.width * _surfaceCells.columns);
                var sh:uint = (_size.height * _surfaceCells.rows);
                var dx:int = (_surfaceCells.x + sw) - this.bitmap.width;
                var dy:int = (_surfaceCells.y + sh) - this.bitmap.height;
                var up:Boolean;
                
                if (dx > 0) {
                    _surfaceCells.x -= dx;
                    up = true;
                }
                
                if (dy > 0) {
                    _surfaceCells.y -= dy;
                    up = true;
                }
                
                if (_surfaceCells.x < 0) {
                    _surfaceCells.x = 0;
                    up = true;
                }
                
                if (_surfaceCells.y < 0) {
                    _surfaceCells.y = 0;
                    up = true;
                }		
                
                if (up) {
                    offsetXStepper.value = _surfaceCells.x;
                    offsetYStepper.value = _surfaceCells.y;
                }
                
                offsetXStepper.maximum = this.bitmap.width - sw;
                offsetYStepper.maximum = this.bitmap.height - sh;
                widthStepper.maximum = Math.floor(this.bitmap.width / 32) * 32;
                heightStepper.maximum = Math.floor(this.bitmap.height / 32) * 32;
                columnsStepper.maximum = Math.floor(this.bitmap.width / _size.width);
                rowsStepper.maximum = Math.floor(this.bitmap.height / _size.height);
            }
            
            protected function onCutImage():void
            {
                if (!this.hasImage) return;
                
                var x:int = offsetXStepper.value;
                var y:int = offsetYStepper.value;
                var width:uint = _size.width;
                var height:uint = _size.height;
                var columns:uint = columnsStepper.value;
                var rows:uint = rowsStepper.value;
                var rect:Rectangle = new Rectangle(0, 0, width, height);
                var point:Point = new Point();
                var list:Vector.<Frame> = new Vector.<Frame>();
                
                _lastValues.setTo(x, y, columns, rows);
                
                for (var c:uint = 0; c < columns; c++) {
                    for (var r:uint = 0; r < rows; r++) {
                        rect.x = x + (c * width);
                        rect.y = y + (r * height);
                        
                        var bmp:BitmapData;
                        if (_transparency)
                            bmp = new BitmapData(width, height, true, 0xFFFF00FF);
                        else
                            bmp = new BitmapData(width, height, false, 0xFF00FF);
                        
                        bmp.copyPixels(this.bitmap, rect, point);
                        bmp = SpriteUtils.removeMagenta(bmp);
                        
                        if (!SpriteUtils.isEmpty(bmp)) {
                            this.framesList.addObject(new Frame(bmp));
                        }
                    }
                }
            }
            
            protected function createThingData():void
            {
                if (framesList.isEmpty) {
                    thingView.thingData = null;
                    return;
                }
                
                var width:uint = _size.width;
                var height:uint = _size.height;
                var thing:ThingType = new ThingType();
                thing.category = getCurrentCategory();
				
				if(thing.category != ThingCategory.OUTFIT) {
					Log.info("NOT OUTFIT");
					thing.id = 0;
					thing.width = (width / 32);
					thing.height = (height / 32);
					thing.layers = 1;
					thing.frames = framesList.length;
					thing.patternX = 1;
					thing.patternY = 1;
					thing.patternZ = 1;
					thing.exactSize = Math.max(width, height);
					thing.animateAlways = false;
					
					// -- -- -- -- --
					thing.hasGroups = false;
					thing.groups = 1;
					
					var spriteCount:uint = thing.width * thing.height * thing.frames;
					var spriteIndices:Vector.<uint> = new Vector.<uint>(spriteCount);
					thing.spriteIndex = spriteIndices;
					
					var sprites:Vector.<SpriteData> = new Vector.<SpriteData>(spriteCount);
					var id:uint = uint.MAX_VALUE;
					var rect:Rectangle = new Rectangle(0, 0, 32, 32);
					
					
					for (var f:uint = 0; f < thing.frames; f++) {
						
						var bmp:BitmapData = framesList.getObjectAt(f).getBitmap();
						for (var w:uint = 0; w < thing.width; w++) {
							for (var h:uint = 0; h < thing.height; h++) {
								
								var index:uint = ThingData.getSpriteIndex(thing, w, h, 0, 0, 0, 0, f);
								rect.x = (thing.width - w - 1) * rect.width;
								rect.y = (thing.height - h - 1) * rect.height;
								var spriteData:SpriteData = new SpriteData();
								spriteData.id = id;
								spriteData.pixels = bmp.getPixels(rect);
								sprites[index] = spriteData;
								spriteIndices[index] = id;

							}
						}
					}
					ThingUtils.createDefaultFrameDurations(thing);
					this.thingView.thingData = ThingData.createThingData(thing, sprites, null);
				} else {
					thing.id = 0;
					thing.width = (width / 32);
					thing.height = (height / 32);
					thing.layers = 1;
					
                    thing.patternX = 4;
                    thing.frames = framesList.length / 4;
					
					thing.patternY = 1;
					thing.patternZ = 1;
					thing.exactSize = Math.max(width, height);
					thing.animateAlways = false;
					
					// -- -- -- -- --
					thing.hasGroups = false;
					thing.groups = 1;
					
					var spriteCount:uint = thing.width * thing.height * thing.patternX * thing.frames;
					var spriteIndices:Vector.<uint> = new Vector.<uint>(spriteCount);
					thing.spriteIndex = spriteIndices;
					
					var sprites:Vector.<SpriteData> = new Vector.<SpriteData>(spriteCount);
					var id:uint = uint.MAX_VALUE;
					var rect:Rectangle = new Rectangle(0, 0, 32, 32);
					
					for (var px:uint = 0; px < thing.patternX; px++) {
						for (var f:uint = 0; f < thing.frames; f++) {
							var v:uint = (px * thing.frames) + f;							
							var bmp:BitmapData = framesList.getObjectAt(v).getBitmap();
							for (var w:uint = 0; w < thing.width; w++) {
								for (var h:uint = 0; h < thing.height; h++) {
									
									var index:uint = ThingData.getSpriteIndex(thing, w, h, 0, px, 0, 0, f);
									rect.x = (thing.width - w - 1) * rect.width;
									rect.y = (thing.height - h - 1) * rect.height;
									var spriteData:SpriteData = new SpriteData();
									spriteData.id = id;
									spriteData.pixels = bmp.getPixels(rect);
									sprites[index] = spriteData;
									spriteIndices[index] = id;

								}
							}
						}
					}
					
					var sprites_2:Vector.<SpriteData> = null;
					if(groupsStepper.value > 1) {
						// now lets calculate groups
						thing.hasGroups = true;
						thing.groups = 2;
						
						var idleCount:uint = iacStepper.value;
						if(idleCount >= thing.frames) {
							idleCount = 1;	// forced default dumbproof
						}
						
						// init attributes
						thing.width_2  = thing.width;
						thing.height_2 = thing.height;
						thing.exactSize_2 = thing.exactSize;
						thing.layers_2 = thing.layers;
						thing.patternX_2 = thing.patternX;
						thing.patternY_2 = thing.patternY;
						thing.patternZ_2 = thing.patternZ;
					
						// split frames
						var originalFrames:uint = thing.frames;
						thing.frames = idleCount;
						thing.frames_2 = originalFrames - idleCount;

						ThingUtils.createDefaultFrameDurations(thing);
						ThingUtils.createDefaultFrameDurations_2(thing);
						
						// make groups
						// recalculate sprites and indexes
						// idle / standing group
						var totalSprites:uint = thing.width * thing.height * thing.layers * thing.patternX * thing.patternY * thing.patternZ * thing.frames;

						var tmp_sprin:Vector.<uint> = new Vector.<uint>(totalSprites);
						var tmp_spr:Vector.<SpriteData> = new Vector.<SpriteData>(totalSprites);
						
						for (var i:uint = 0; i < totalSprites; i++) {
							tmp_sprin[i] = thing.spriteIndex[i];
							tmp_spr[i] = sprites[i];
						}
						
						var orig_sprin:Vector.<uint> = thing.spriteIndex;
						var orig_spr:Vector.<SpriteData> = sprites;
						
						thing.spriteIndex = tmp_sprin;
						sprites = tmp_spr;
						
						// -- -- -- -- --
						// walking group
						var toadd:uint = totalSprites;
						totalSprites = thing.width_2 * thing.height_2 * thing.layers_2 * thing.patternX_2 * thing.patternY_2 * thing.patternZ_2 * thing.frames_2;

						// calculate sprites and indexes
						tmp_sprin = new Vector.<uint>(totalSprites);
						tmp_spr = new Vector.<SpriteData>(totalSprites);
						
						for (var i:uint = 0; i < totalSprites; i++) {
							tmp_sprin[i] = orig_sprin[i + toadd];
							tmp_spr[i] = orig_spr[i + toadd];
						}
						
						thing.spriteIndex_2 = tmp_sprin;
						sprites_2 = tmp_spr;
					}
					this.thingView.thingData = ThingData.createThingData(thing, sprites, sprites_2);
				}
            }
            
            protected function getCurrentCategory():String
            {
                switch (categoryDropDownList.selectedIndex) {
                    case 0:
                        return ThingCategory.ITEM;
                    case 1:
                        return ThingCategory.OUTFIT;
                    case 2:
                        return ThingCategory.EFFECT;
                    case 3:
                        return ThingCategory.MISSILE;
                }
                return null;
            }
            
            protected function resetControls():void
            {
                offsetXStepper.value = 0;
                offsetYStepper.value = 0;
                columnsStepper.value = 1;
                rowsStepper.value = 1;
                zoomSlider.value = 1.0;
                zoom = 1.0;
                _surfaceCells.x = 0;
                _surfaceCells.y = 0;
                widthStepper.value = 32;
                heightStepper.value = 32;
                _size.width = 32;
                _size.height = 32;
                thingView.thingData = null;
                framesList.removeAll();
            }
            
            protected function onExportThingData():void
            {
                if (!thingView.thingData)
                    return;
                
                var window:ExportWindow = new ExportWindow();
                window.enableObdFormat = true;
                window.fileName = getCurrentCategory() + "_" + StringUtil.randomKeyString();
                window.directory = application.settings.getIODirectory();
                window.format = application.settings.getLastExportThingFormat();
                window.version = application.settings.getLastExportThingVersion();
                window.addEventListener(Event.CLOSE, windowCloseHandler);
                window.open();
                
                PopUpWindowManager.addWindow(window);
                
                function windowCloseHandler(event:Event):void
                {
                    if (window.fileName == null || !window.directory || window.format == null) {
                        return;
                    }
                    
                    var file:File = window.directory.resolvePath(window.fileName + "." + window.format);
                    var backgoundColor:uint = true ? 0x00FF00FF : 0xFFFF00FF;
                    var bytes:ByteArray;
                    var bitmap:BitmapData;
                    var format:String = file.extension;
                    
                    var helper:SaveHelper = new SaveHelper();
                    if (ImageFormat.hasImageFormat(format)) {
                        bitmap = ThingData.getSpriteSheet(thingView.thingData, null, backgoundColor);
                        bytes = ImageCodec.encode(bitmap, format);
                    } else if (format == OTFormat.OBD) {
                        bytes = ThingData.serialize(thingView.thingData, window.version);
                    }
                    
                    helper.addFile(bytes, window.fileName, format, file);
                    helper.save();
                    
                    application.settings.setIODirectory(window.directory);
                    application.settings.setLastExportThingVersion(window.version);
                }
            }
            
            protected function onPaste():void
            {
                if (!ClipboardBitmapLoader.hasBitmapFormat)
                    return;
                
                var loader:ClipboardBitmapLoader = new ClipboardBitmapLoader();
                loader.addEventListener(Event.COMPLETE, completeHandler);
                loader.load();
                
                function completeHandler(event:Event):void
                {
                    setBitmap(loader.bitmap);
                }
            }
            
            //--------------------------------------
            // Override Protected
            //--------------------------------------
            
            override protected function createChildren():void
            {
                super.createChildren();
                
                _surfaceCells = new SurfaceCells();
                _surfaceCells.blendMode = BlendMode.INVERT;
                _surfaceCells.addEventListener(MouseEvent.MOUSE_DOWN, surfaceCellsMouseDownHandler);
                _surfaceCells.addEventListener(MouseEvent.MOUSE_UP, surfaceCellsMouseUpHandler);
                _surfaceCells.addEventListener(MoveEvent.MOVE, surfaceCellsMoveHandler);
                imageConteinerGroup.addElement(_surfaceCells);
            }
            
            override protected function commitProperties():void
            {
                super.commitProperties();
                
                if (_fileChanged) {
                    setFile(_file);
                    _fileChanged = false;
                }
                
                if (_bitmapChanged) {
                    setBitmap(_nextBitmap);
                    _nextBitmap = null;
                    _bitmapChanged = false;
                }
                
                if (_zoomChanged) {
                    imageConteinerGroup.scaleX = _zoom;
                    imageConteinerGroup.scaleY = _zoom;
                    _zoomChanged = false;
                }
            }
            
            //--------------------------------------
            // Private
            //--------------------------------------
            
            private function setFile(file:File):void
            {
                if (!file || (file.extension != OTFormat.OBD && !ImageFormat.hasImageFormat(file.extension)))
                    return;
                
                try
                {
                    if (file.extension == OTFormat.OBD)
                        openOBD(file);
                    else if (file.extension == ImageFormat.GIF)
                        openGif(file);
                    else
                        ImageCodec.decodeFromFile(file, imageReadCallback);
                    
                    application.settings.setLastDirectory(FileUtil.getDirectory(file));
                } catch(error:Error) {
                    Alert.show(error.getStackTrace(), resourceManager.getString("strings", "error"), Alert.OK, this);
                }
                
                function imageReadCallback(bitmap:BitmapData):void
                {
                    setBitmap(bitmap);
                }
            }
            
            private function openOBD(file:File):void
            {
                var thingData:ThingData = ThingData.createFromFile(file);
                if (!thingData)
                    return;
                
                var bitmap:BitmapData = ThingData.getSpriteSheet(thingData, null, 0);
                setBitmap(bitmap);
            }
            
            private function openGif(file:File):void
            {
                var stream:FileStream = new FileStream();
                stream.open(file, FileMode.READ);
                
                var decoder:GIFDecoder = new GIFDecoder();
                decoder.addEventListener(GIFDecoderEvent.DECODE_COMPLETE, gifDecoderCompleteHandler);
                decoder.decodeBytes(stream);
                stream.close();
            }
            
            private function setBitmap(bitmap:BitmapData):void
            {
                _bitmap = bitmap;
                imageControl.source = bitmap;
                
                resetControls();
                update();
            }
            
            private function onOpenFile():void
            {
                var filters:Array = ObUtils.createImagesFileFilter();
                filters[0].extension += "*.obd";
                filters.splice(1, 0, new FileFilter("Object Builder Data (*.OBD)", "*.obd"));
                var file:File = application.settings.getLastDirectory() || File.userDirectory;
                file.addEventListener(Event.SELECT, fileSelectHandler);
                file.browseForOpen(resourceManager.getString("strings", "selectFile"), filters);
                
                function fileSelectHandler(event:Event):void
                {
                    setFile(file);
                }
            }
            
            private function removeSelectedFrames():void
            {
                if (!thingView.thingData)
                    return;
                
                this.framesList.removeSelectedIndices();
                this.framesList.refresh();
                this.createThingData();
            }
            
            private function importImagesFromFiles(list:Vector.<File>):void
            {
                ImageCodec.decodeFromFile(list[0], imageDecodeCallback);
                
                function imageDecodeCallback(bitmap:BitmapData):void
                {
                    setBitmap(bitmap);
                }
            }
            
            private function duplicateSelectedFrames():void
            {
                var list:Vector.<Frame> = framesList.selectedFrames;
                if (list.length > 0) {
                    var length:uint = list.length;
                    for (var i:int = length - 1; i >= 0; i--) {
                        framesList.addObject(list[i].clone());
                    }
                }
            }
            
            //--------------------------------------
            // Event Handlers
            //--------------------------------------
            
            protected function creationCompleteHandler(event:FlexEvent):void
            {
                systemManager.stage.addEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);
            }
            
            protected function imageContainerMouseMoveHandler(event:MouseEvent):void
            {
                if (_bitmap && _mouseDown) {
                    offsetXStepper.value = _surfaceCells.x;
                    offsetYStepper.value = _surfaceCells.y;
                }
            }
            
            protected function imageContainerMouseDownHandler(event:MouseEvent):void
            {
                if (!this.hasImage) return;
                
                if (event.target != _surfaceCells && event.localX <= this.bitmap.width && event.localY <= this.bitmap.height) {
                    var px:Number = Math.round(event.localX - _surfaceCells.width * 0.5);
                    var py:Number = Math.round(event.localY - _surfaceCells.height * 0.5);
                    
                    _surfaceCells.move(px, py);
                    
                    update();
                    surfaceCellsMouseDownHandler(event);
                }
            }
            
            protected function surfaceCellsMouseDownHandler(event:MouseEvent):void
            {
                _mouseDown = true;
                
                _rect.width  = imageControl.width - _surfaceCells.width;
                _rect.height = imageControl.height - _surfaceCells.height;
                
                cursorManager.setCursor(NailAssets.MOVE_CURSOR, 2, -8, -8);
                
                _surfaceCells.startDrag(false,_rect);
                
                systemManager.stage.addEventListener(MouseEvent.MOUSE_UP, surfaceCellsMouseUpHandler);
            }
            
            protected function surfaceCellsMouseUpHandler(event:MouseEvent):void
            {
                systemManager.stage.removeEventListener(MouseEvent.MOUSE_UP, surfaceCellsMouseUpHandler);
                
                _mouseDown = false;
                
                _surfaceCells.stopDrag();
                
                cursorManager.removeCursor(cursorManager.currentCursorID);
            }
            
            protected function surfaceCellsMoveHandler(event:MoveEvent):void
            {
                _surfaceCells.x = Math.round(_surfaceCells.x);
                _surfaceCells.y = Math.round(_surfaceCells.y);
            }
            
            protected function offsetStepperChangeHandler(event:Event):void
            {
                _surfaceCells.x = offsetXStepper.value;
                _surfaceCells.y = offsetYStepper.value;
            }
            
            protected function sizeStepperChangeHandler(event:Event):void
            {
                _size.width = widthStepper.value;
                _size.height = heightStepper.value;
                framesList.removeAll();
                thingView.thingData = null;
                update();
            }
            
            protected function zoomChangeHandler(event:Event):void
            {
                this.zoom = HSlider(event.target).value;
            }
            
            protected function imageConteinerGroupNativeDragEnterHandler(event:NativeDragEvent):void
            {
                if (event.target == imageConteinerGroup) {
                    if (event.clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT)) {
                        NativeDragManager.dropAction = NativeDragActions.LINK;
                        DragManager.acceptDragDrop(imageConteinerGroup);
                    }
                }
            }
            
            protected function imageConteinerGroupNativeDragDropHandler(event:NativeDragEvent):void
            {
                var clipboard:Clipboard = event.clipboard;
                if (clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT)) {
                    var dropfiles:Array = clipboard.getData(ClipboardFormats.FILE_LIST_FORMAT) as Array;
                    
                    FileUtil.sortFiles(dropfiles, Array.NUMERIC | Array.DESCENDING);
                    
                    var length:uint = dropfiles.length;
                    var list:Vector.<File> = new Vector.<File>();
                    for (var i:uint = 0; i < length; i++) {
                        var file:File = dropfiles[i];
                        if (FileUtil.hasBitmapFormat(file)) {
                            list[list.length] = file;
                        }
                    }
                }
                
                if (list.length > 0) {
                    importImagesFromFiles(list);
                }
            }
            
            protected function menuItemClickHandler(event:MenuEvent):void
            {
                var data:String = String(event.item.@data);
                switch(data) {
                    case "fileOpen":
                        this.onOpenFile();
                        break;
                    case "fileExport":
                        this.onExportThingData();
                        break;
                    case "editPaste":
                        this.onPaste();
                        break;
                }
            }
            
            protected function menuBarShowHandler(event:MenuEvent):void
            {
                menuXML[0].menuitem[1].@enabled = (thingView.thingData != null);
                menuXML[1].menuitem[0].@enabled = ClipboardBitmapLoader.hasBitmapFormat;
            }
            
            protected function animationsListDuplicateHandler(event:FrameListEvent):void
            {
                duplicateSelectedFrames();
            }
            
            protected function cutButtonClickHandler(event:MouseEvent):void
            {
                this.onCutImage();
                this.createThingData();
            }
            
            protected function animationsListDragCompleteHandler(event:DragEvent):void
            {
                this.createThingData();
                this.framesList.refresh();
            }
            
            protected function playButtonChangeHandler(event:Event):void
            {
                if (playButton.selected) {
                    playButton.setStyle("icon", Icons.PAUSE);
                    playButton.toolTip = resourceManager.getString("strings", "pause");
                    thingView.play();
                } else {
                    playButton.setStyle("icon", Icons.PLAY);
                    playButton.toolTip = resourceManager.getString("strings", "play");
                    thingView.pause();
                }
            }
            
            protected function dulicateFrameButtonClickHandler(event:MouseEvent):void
            {
                this.duplicateSelectedFrames();
            }
            
            protected function deleteFrameButtonClickHandler(event:MouseEvent):void
            {
                if (!thingView.thingData)
                    return;
                
                this.framesList.removeSelectedIndices();
                this.framesList.refresh();
                this.createThingData();
            }
            
            protected function thingViewChangeHandler(event:Event):void
            {
                framesList.selectedIndex = thingView.frame;
            }
            
            protected function framesListChangeHandler(event:IndexChangeEvent):void
            {
                if (!thingView.thingData)
                    return;
                
                thingView.frame = framesList.selectedIndex;
            }
            
            protected function gifDecoderCompleteHandler(event:GIFDecoderEvent):void
            {
                var gifFrames:Vector.<GIFFrame> = GIFDecoder(event.target).frames;
                var frames:Vector.<Frame> = new Vector.<Frame>();
                var length:uint = gifFrames.length;
                for (var i:uint = 0; i < length; i++) {
                    var frame:GIFFrame = gifFrames[i];
                    var f:Frame = new Frame(frame.bitmapData);
                    frames[frames.length] = f;
                }
                
                _size.width = gifFrames[0].width;
                _size.height = gifFrames[0].height;
                framesList.setListObjects(frames);
                createThingData();
            }
            
            override protected function keyDownHandler(event:KeyboardEvent):void
            {
                var keyCode:uint = event.keyCode;
                
                if (event.ctrlKey && !event.shiftKey) {
                    switch(keyCode) {
                        case Keyboard.O:
                            this.onOpenFile();
                            break;
                        case Keyboard.E:
                            this.onExportThingData();
                            break;
                        case Keyboard.V:
                            this.onPaste();
                            break;
                        case Keyboard.MINUS:
                            this.zoom = Math.max(zoomSlider.minimum, this.zoom - 0.1);
                            break;
                        case Keyboard.EQUAL:
                            this.zoom = Math.min(zoomSlider.maximum, this.zoom + 0.1);
                            break;
                    }
                } else if (!event.ctrlKey && event.shiftKey) {
                    
                } else {
                    switch(keyCode) {
                        case Keyboard.DELETE:
                            this.removeSelectedFrames();
                            break;
                    }
                }
            }
            
        ]]>
    </fx:Script>
    
    <!-- menu bar -->
    <s:Group width="100%"
             height="31">
        <!-- fill -->
        <s:Rect left="-1" right="-1" top="1" bottom="0">
            <s:fill>
                <s:SolidColor color="0x494949"/>
            </s:fill>
        </s:Rect>
        
        <!-- border -->
        <s:Rect left="-1" right="-1" top="0" bottom="0">
            <s:stroke>
                <s:SolidColorStroke color="0x272727"/>
            </s:stroke>
        </s:Rect>
        
        <mx:MenuBar id="menuBar"
                    width="100%"
                    top="4"
                    fontSize="11"
                    labelField="@label"
                    iconField="@icon"
                    showRoot="true"
                    dataProvider="{menuXML}"
                    itemSkin="nail.components.skins.MenuBarItemSkin"
                    itemClick="menuItemClickHandler(event)"
                    menuShow="menuBarShowHandler(event)"/>
    </s:Group>
    
    <mx:HDividedBox width="100%"
                    height="100%">
        <s:BorderContainer id="controlsContainer"
                           minWidth="245"
                           maxWidth="300"
                           width="300"
                           height="100%"
                           skinClass="nail.components.skins.BorderContainerSkin">
            <s:layout>
                <s:VerticalLayout paddingLeft="5"
                                  paddingRight="5"
                                  paddingTop="10"
                                  paddingBottom="10"
                                  verticalAlign="bottom"/>
            </s:layout>
            
            <nail:GroupBox id="thingViewGroup"
                           label="@Resource(key='preview', bundle='strings')"
                           width="100%"
                           height="100%">
                <components:ThingDataView id="thingView"
                                          horizontalCenter="0"
                                          verticalCenter="0"
                                          change="thingViewChangeHandler(event)"/>
                
            </nail:GroupBox>
            
            <nail:GroupBox label="@Resource(key='properties', bundle='strings')"
                           width="100%">
                <nail:layout>
                    <s:VerticalLayout paddingLeft="10"
                                      paddingRight="10"
                                      paddingTop="10"
                                      paddingBottom="10"
                                      horizontalAlign="right"/>
                </nail:layout>
                <s:TileGroup requestedColumnCount="2"
                             columnWidth="100"
                             verticalAlign="middle">
                    <s:Label text="{resourceManager.getString('strings', 'category') + ':'}"
                             textAlign="right"/>
                    <s:DropDownList id="categoryDropDownList"
                                    requireSelection="true"
                                    minWidth="70"
                                    change="createThingData()">
                        <s:dataProvider>
                            <s:ArrayList>
                                <fx:String>{resourceManager.getString('strings', 'item')}</fx:String>
                                <fx:String>{resourceManager.getString('strings', 'outfit')}</fx:String>
                                <fx:String>{resourceManager.getString('strings', 'effect')}</fx:String>
                                <fx:String>{resourceManager.getString('strings', 'missile')}</fx:String>
                            </s:ArrayList>
                        </s:dataProvider>
                    </s:DropDownList>
                    <s:Label text="X:"
                             textAlign="right"/>
                    <s:NumericStepper id="offsetXStepper"
                                      minWidth="70"
                                      minimum="0"
                                      maximum="608"
                                      change="offsetStepperChangeHandler(event)"/>
                    <s:Label text="Y:"
                             textAlign="right"/>
                    <s:NumericStepper id="offsetYStepper"
                                      minWidth="70"
                                      minimum="0"
                                      maximum="608"
                                      change="offsetStepperChangeHandler(event)"/>
                    <s:Label text="{resourceManager.getString('strings', 'width') + ':'}"
                             textAlign="right"/>
                    <s:NumericStepper id="widthStepper"
                                      minWidth="70"
                                      minimum="32"
                                      maximum="1028"
                                      stepSize="32"
                                      change="sizeStepperChangeHandler(event)"/>
                    <s:Label text="{resourceManager.getString('strings', 'height') + ':'}"
                             textAlign="right"/>
                    <s:NumericStepper id="heightStepper"
                                      minWidth="70"
                                      minimum="32"
                                      maximum="1028"
                                      stepSize="32"
                                      change="sizeStepperChangeHandler(event)"/>
                    <s:Label text="{resourceManager.getString('strings', 'columns') + ':'}"
                             textAlign="right"/>
                    <s:NumericStepper id="columnsStepper"
                                      minWidth="70"
                                      minimum="1"
                                      maximum="20"
                                      change="update()"/>
                    <s:Label text="{resourceManager.getString('strings', 'rows') + ':'}"
                             textAlign="right"/>
                    <s:NumericStepper id="rowsStepper"
                                      minWidth="70"
                                      minimum="1"
                                      maximum="20"
                                      change="update()"/>
                    <s:Label text="{'Groups:'}"
                             textAlign="right"/>
                    <s:NumericStepper id="groupsStepper"
                                      minWidth="70"
                                      minimum="1"
                                      maximum="2"/>
                    <s:Label text="{'Idle animation count:'}"
                             textAlign="right"
							 visible="{groupsStepper.value > 1}"/>
                    <s:NumericStepper id="iacStepper"
                                      minWidth="70"
                                      minimum="1"
                                      maximum="999"
									  visible="{groupsStepper.value > 1}"/>
									  
                </s:TileGroup>
            </nail:GroupBox>
            
            <nail:GroupBox label="@Resource(key='zoom', bundle='strings')"
                           width="100%">
                <nail:layout>
                    <s:VerticalLayout paddingLeft="5"
                                      paddingRight="5"
                                      paddingTop="10"
                                      paddingBottom="10"/>
                </nail:layout>
                <s:HSlider id="zoomSlider"
                           width="100%"
                           minimum="1.0"
                           maximum="5.0"
                           stepSize="0.1"
                           value="{zoom}"
                           bottom="10"
                           right="10"
                           change="zoomChangeHandler(event)"/>
            </nail:GroupBox>
            
            <s:Spacer height="3"/>
            <nail:ShadowLine width="100%"/>
            <s:Spacer height="3"/>
            
            <s:Button id="cutButton"
                      label="@Resource(key='crop', bundle='strings')"
                      width="100%"
                      click="cutButtonClickHandler(event)"/>
        </s:BorderContainer>
        
        <s:VGroup width="100%"
                  height="100%"
                  gap="0">
            <s:BorderContainer width="100%"
                               height="100%"
                               skinClass="nail.components.skins.BorderContainerSkin">
                <s:layout>
                    <s:VerticalLayout paddingLeft="1"
                                      paddingRight="0"
                                      paddingTop="1"
                                      paddingBottom="0"/>
                </s:layout>
                <s:Scroller width="100%"
                            height="100%"
                            verticalScrollPolicy="on"
                            horizontalScrollPolicy="on">
                    
                    <s:Group id="imageConteinerGroup"
                             width="100%"
                             height="100%"
                             mouseMove="imageContainerMouseMoveHandler(event)"
                             mouseDown="imageContainerMouseDownHandler(event)"
                             nativeDragEnter="imageConteinerGroupNativeDragEnterHandler(event)"
                             nativeDragDrop="imageConteinerGroupNativeDragDropHandler(event)">
                        
                        <components:CheckerBoard id="checkerboard"
                                                 width="{imageControl.width}"
                                                 height="{imageControl.height}"/>
                        
                        <s:Image id="imageControl"/>
                        
                        <s:SpriteVisualElement id="surfaceLine"
                                               width="100%"
                                               height="100%"
                                               blendMode="invert"/>	
                    </s:Group>
                </s:Scroller>
            </s:BorderContainer>
            
            <s:BorderContainer width="100%"
                               height="155"
                               skinClass="nail.components.skins.BorderContainerSkin">
                <s:layout>
                    <s:VerticalLayout gap="0"/>
                </s:layout>
                <animationeditor:FrameList id="framesList"
                                           width="100%"
                                           height="100%"
                                           contentBackgroundColor="0x494949"
                                           borderVisible="false"
                                           requireSelection="true"
                                           allowMultipleSelection="true"
                                           dragEnabled="true"
                                           dragMoveEnabled="true"
                                           dropEnabled="true"
                                           horizontalScrollPolicy="on"
                                           verticalScrollPolicy="off"
                                           itemRenderer="nail.animationeditor.renders.FrameListRenderer"
                                           duplicate="animationsListDuplicateHandler(event)"
                                           remove="removeSelectedFrames()"
                                           dragComplete="animationsListDragCompleteHandler(event)"
                                           change="framesListChangeHandler(event)">
                    <animationeditor:layout>
                        <s:HorizontalLayout verticalAlign="middle"
                                            gap="0"/>
                    </animationeditor:layout>
                </animationeditor:FrameList>
                <s:HGroup width="100%"
                          height="25"
                          paddingLeft="5"
                          paddingRight="5"
                          paddingTop="2"
                          paddingBottom="2">
                    <s:Button id="firstFrameButton"
                              width="19"
                              height="19"
                              toolTip="@Resource(key='firstFrame', bundle='strings')"
                              icon="{Icons.FIRST}"
                              click="{thingView.fistFrame()}"/>
                    <s:Button id="previousFrameButton"
                              width="19"
                              height="19"
                              toolTip="@Resource(key='previousFrame', bundle='strings')"
                              icon="{Icons.PREVIOUS}"
                              autoRepeat="true"
                              repeatInterval="200"
                              buttonDown="{thingView.prevFrame()}"/>
                    <s:ToggleButton id="playButton"
                                    width="19"
                                    height="19"
                                    toolTip="@Resource(key='play', bundle='strings')"
                                    icon="{Icons.PLAY}"
                                    change="playButtonChangeHandler(event)"/>
                    <s:Button id="nextFrameButton" width="19"
                              height="19"
                              toolTip="@Resource(key='nextFrame', bundle='strings')"
                              icon="{Icons.NEXT}"
                              autoRepeat="true"
                              repeatInterval="200"
                              buttonDown="{thingView.nextFrame()}"/>
                    <s:Button id="lastFrameButton"
                              width="19"
                              height="19"
                              toolTip="@Resource(key='lastFrame', bundle='strings')"
                              icon="{Icons.LAST}"
                              click="{thingView.lastFrame()}"/>
                    <nail:ShadowLine height="100%"/>
                    <s:Button id="dulicateFrameButton"
                              width="19"
                              height="19"
                              toolTip="@Resource(key='duplicateFrame', bundle='strings')"
                              icon="{Icons.DUPLICATE}"
                              click="dulicateFrameButtonClickHandler(event)"/>
                    <s:Button id="deleteFrameButton" width="19"
                              height="19"
                              toolTip="@Resource(key='deleteFrame', bundle='strings')"
                              icon="{Icons.DELETE}"
                              click="deleteFrameButtonClickHandler(event)"/>
                </s:HGroup>
            </s:BorderContainer>
        </s:VGroup>
    </mx:HDividedBox>
</s:Window>
